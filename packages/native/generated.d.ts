/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** A workflow activation job containing work for the Node.js SDK to process. */
export interface WorkflowActivationJob {
  /**
   * Job type: "initialize", "fire_timer", "resolve_task", "fail_task",
   * "resolve_promise", "reject_promise", "timeout_promise",
   * "resolve_child_workflow", "fail_child_workflow", "cancel_workflow",
   * "signal", "query"
   */
  jobType: string
  /** Serialized job data as JSON string. */
  data: string
}
/** A key-value pair for workflow state. */
export interface StateEntry {
  /** State key. */
  key: string
  /** Serialized value as base64 string. */
  value: string
}
/** Workflow activation data (passed as plain object, not class instance). */
export interface WorkflowActivationData {
  /** Workflow execution ID. */
  workflowExecutionId: string
  /** Org ID. */
  orgId: string
  /** The workflow kind/type. */
  workflowKind: string
  /** Serialized workflow input as JSON string. */
  input: string
  /** Jobs to process in this activation. */
  jobs: Array<WorkflowActivationJob>
  /** Replay events as JSON strings. */
  replayEvents: Array<string>
  /** State entries. */
  stateEntries: Array<StateEntry>
  /** Current timestamp in milliseconds. */
  timestampMs: number
  /** Random seed for deterministic randomness. */
  randomSeed: string
  /** Whether cancellation has been requested. */
  cancellationRequested: boolean
}
/** Workflow completion status type. */
export const enum WorkflowCompletionStatusType {
  Completed = 'Completed',
  Suspended = 'Suspended',
  Cancelled = 'Cancelled',
  Failed = 'Failed'
}
/** Workflow completion status with data. */
export interface WorkflowCompletionStatus {
  /** Status type. */
  status: WorkflowCompletionStatusType
  /** Serialized output as JSON string (if completed). */
  output?: string
  /** Reason (if cancelled). */
  reason?: string
  /** Error message (if failed). */
  error?: string
  /** Commands to submit (as JSON array string). */
  commands?: string
}
/** Task activation data (passed as plain object, not class instance). */
export interface TaskActivationData {
  /** The task execution ID. */
  taskExecutionId: string
  /** The task kind/type. */
  taskKind: string
  /** Serialized task input as JSON string. */
  input: string
  /** Workflow execution ID that scheduled this task (if any). */
  workflowExecutionId?: string
  /** Current attempt number (1-based). */
  attempt: number
  /** Maximum number of retries. */
  maxRetries: number
  /** Timeout in milliseconds (if set). */
  timeoutMs?: number
}
/** Task completion status type. */
export const enum TaskCompletionStatusType {
  Completed = 'Completed',
  Failed = 'Failed',
  Cancelled = 'Cancelled'
}
/** Completion sent back after processing a task activation. */
export interface TaskCompletion {
  /** The task execution ID. */
  taskExecutionId: string
  /** Status type. */
  status: TaskCompletionStatusType
  /** Serialized output as JSON string (if completed). */
  output?: string
  /** Error message (if failed). */
  error?: string
  /** Whether this is retryable (if failed). */
  retryable?: boolean
}
/** Result of starting a workflow. */
export interface StartWorkflowResult {
  /** The workflow execution ID. */
  workflowExecutionId: string
  /** Whether the idempotency key was used (for idempotent requests). */
  idempotencyKeyUsed: boolean
  /** Whether this created a new workflow (vs finding existing). */
  idempotencyKeyNew: boolean
}
/** Options for starting a workflow. */
export interface StartWorkflowOptions {
  /** Queue to run the workflow on (optional, uses default if not provided). */
  queue?: string
  /** Workflow version (optional). */
  workflowVersion?: string
  /** Idempotency key for deduplication (optional). */
  idempotencyKey?: string
}
/** Result of signaling a workflow. */
export interface SignalWorkflowResult {
  /** Sequence number of the signal event. */
  signalEventSequence: number
}
/** Result of signal-with-start operation. */
export interface SignalWithStartResult {
  /** The workflow execution ID. */
  workflowExecutionId: string
  /** Whether the workflow was created (vs already existed). */
  workflowCreated: boolean
  /** Sequence number of the signal event. */
  signalEventSequence: number
}
/** OAuth2 client credentials for authentication. */
export interface OAuth2Credentials {
  /** OAuth2 client ID. */
  clientId: string
  /** OAuth2 client secret. */
  clientSecret: string
  /** Token endpoint URL (e.g., `https://keycloak.example.com/realms/myrealm/protocol/openid-connect/token`). */
  tokenEndpoint: string
  /** Optional scopes (space-separated if multiple). */
  scopes?: string
}
/** Workflow metadata for registration. */
export interface WorkflowMetadata {
  /** Unique workflow kind identifier (required). */
  kind: string
  /** Human-readable name (defaults to kind if empty). */
  name: string
  /** Optional description. */
  description?: string
  /** Version string (e.g., "1.0.0"). */
  version?: string
  /** Tags for categorization. */
  tags: Array<string>
  /** Whether the workflow can be cancelled. */
  cancellable: boolean
  /** Timeout in seconds. */
  timeoutSeconds?: number
  /** JSON Schema for input validation (JSON string). */
  inputSchema?: string
  /** JSON Schema for output validation (JSON string). */
  outputSchema?: string
}
/** Task metadata for registration. */
export interface TaskMetadata {
  /** Unique task kind identifier (required). */
  kind: string
  /** Human-readable name (defaults to kind if empty). */
  name: string
  /** Optional description. */
  description?: string
  /** Version string (e.g., "1.0.0"). */
  version?: string
  /** Tags for categorization. */
  tags: Array<string>
  /** Whether the task can be cancelled. */
  cancellable: boolean
  /** Timeout in seconds. */
  timeoutSeconds?: number
  /** JSON Schema for input validation (JSON string). */
  inputSchema?: string
  /** JSON Schema for output validation (JSON string). */
  outputSchema?: string
}
/** Configuration for creating a NapiWorker. */
export interface WorkerConfig {
  /** Server URL (e.g., `http://localhost:9090`). */
  serverUrl: string
  /**
   * Worker token for authentication (should start with "fwt_").
   * If not provided or not starting with "fwt_", a placeholder will be used.
   * Ignored if oauth2_credentials is provided.
   */
  workerToken?: string
  /**
   * OAuth2 client credentials for authentication.
   * If provided, the SDK will fetch a JWT using client credentials flow.
   */
  oauth2Credentials?: OAuth2Credentials
  /** Org ID (UUID format) for worker registration. */
  orgId: string
  /** Task queue to poll for work. */
  queue: string
  /** Optional worker identity for debugging/monitoring. */
  workerIdentity?: string
  /** Maximum concurrent workflow tasks (default: 100). */
  maxConcurrentWorkflowTasks?: number
  /** Maximum concurrent activity tasks (default: 100). */
  maxConcurrentTasks?: number
  /** Workflow metadata for this worker. */
  workflowMetadata: Array<WorkflowMetadata>
  /** Task metadata for this worker. */
  taskMetadata: Array<TaskMetadata>
}
/** Configuration for creating a NapiClient. */
export interface ClientConfig {
  /** Server URL (e.g., `http://localhost:9090`). */
  serverUrl: string
  /**
   * Client token for authentication (should start with "fct_").
   * If not provided, a placeholder will be used.
   * Ignored if oauth2_credentials is provided.
   */
  clientToken?: string
  /**
   * OAuth2 client credentials for authentication.
   * If provided, the SDK will fetch a JWT using client credentials flow.
   */
  oauth2Credentials?: OAuth2Credentials
  /** Org ID (UUID format) for operations. */
  orgId: string
}
/** Result of scheduling a task. */
export interface TaskResult {
  /** Status: "completed", "failed", or "pending" */
  status: string
  /** Serialized output as JSON string (if completed). */
  output?: string
  /** Error message (if failed). */
  error?: string
  /** Whether this is retryable (if failed). */
  retryable?: boolean
  /** The task execution ID (if pending or for tracking). */
  taskExecutionId?: string
}
/** Result of creating a promise. */
export interface PromiseResult {
  /** Status: "resolved", "rejected", "timed_out", or "pending" */
  status: string
  /** Serialized value as JSON string (if resolved). */
  value?: string
  /** Error message (if rejected). */
  error?: string
  /** The promise ID (for tracking). */
  promiseId: string
}
/** Result of starting a timer. */
export interface TimerResult {
  /** Status: "fired" or "pending" */
  status: string
  /** The timer ID (for tracking). */
  timerId: string
}
/** Result of scheduling a child workflow. */
export interface ChildWorkflowResult {
  /** Status: "completed", "failed", or "pending" */
  status: string
  /** Serialized output as JSON string (if completed). */
  output?: string
  /** Error message (if failed). */
  error?: string
  /** The child execution ID (for tracking). */
  childExecutionId?: string
}
/** Result of running a side effect operation. */
export interface OperationResult {
  /** Status: "cached" or "execute" */
  status: string
  /** Cached value as JSON string (if cached). */
  value?: string
  /** Sequence number for this operation (if execute). */
  operationSeq?: number
}
/** Result of waiting for a signal. */
export interface SignalResult {
  /** Status: "received" or "pending" */
  status: string
  /** Signal name (if received). */
  signalName?: string
  /** Serialized value as JSON string (if received). */
  value?: string
}
/** A signal event from the signal queue. */
export interface SignalEvent {
  /** Signal name. */
  signalName: string
  /** Serialized value as JSON string. */
  value: string
}
/** Event types that can occur during workflow execution. */
export const enum NapiEventType {
  WorkflowStarted = 'WorkflowStarted',
  WorkflowCompleted = 'WorkflowCompleted',
  WorkflowExecutionFailed = 'WorkflowExecutionFailed',
  WorkflowSuspended = 'WorkflowSuspended',
  CancellationRequested = 'CancellationRequested',
  OperationCompleted = 'OperationCompleted',
  StateSet = 'StateSet',
  StateCleared = 'StateCleared',
  TaskScheduled = 'TaskScheduled',
  TaskCompleted = 'TaskCompleted',
  TaskFailed = 'TaskFailed',
  TaskCancelled = 'TaskCancelled',
  PromiseCreated = 'PromiseCreated',
  PromiseResolved = 'PromiseResolved',
  PromiseRejected = 'PromiseRejected',
  PromiseTimeout = 'PromiseTimeout',
  ChildWorkflowInitiated = 'ChildWorkflowInitiated',
  ChildWorkflowStarted = 'ChildWorkflowStarted',
  ChildWorkflowCompleted = 'ChildWorkflowCompleted',
  ChildWorkflowFailed = 'ChildWorkflowFailed',
  ChildWorkflowCancelled = 'ChildWorkflowCancelled',
  TimerStarted = 'TimerStarted',
  TimerFired = 'TimerFired',
  TimerCancelled = 'TimerCancelled',
  SignalReceived = 'SignalReceived'
}
/** Replay event for NAPI bindings. */
export interface NapiReplayEvent {
  /** Sequence number of this event (1-indexed). */
  sequenceNumber: number
  /** Type of the event. */
  eventType: NapiEventType
  /** Event data as JSON string. */
  data: string
  /** Timestamp in milliseconds since Unix epoch. */
  timestampMs: number
}
/** Worker metrics for NAPI bindings. */
export interface WorkerMetrics {
  /** Uptime in milliseconds. */
  uptimeMs: number
  /** Current worker status. */
  status: string
  /** Server-assigned worker ID (if registered). */
  workerId?: string
  /** Total workflows processed. */
  workflowsProcessed: number
  /** Total tasks processed. */
  tasksProcessed: number
  /** Currently active workflows. */
  activeWorkflows: number
  /** Currently active tasks. */
  activeTasks: number
}
/** Registration information for NAPI bindings. */
export interface RegistrationInfo {
  /** Server-assigned worker ID. */
  workerId: string
  /** Whether registration was successful. */
  success: boolean
  /** When the worker was registered (ms since epoch). */
  registeredAtMs: number
  /** Registered workflow kinds. */
  workflowKinds: Array<string>
  /** Registered task kinds. */
  taskKinds: Array<string>
  /** Whether there are any registration conflicts. */
  hasConflicts: boolean
}
/** Connection information for NAPI bindings. */
export interface ConnectionInfo {
  /** Whether currently connected. */
  connected: boolean
  /** Time of last successful heartbeat (ms since epoch, if any). */
  lastHeartbeatMs?: number
  /** Time of last successful poll (ms since epoch, if any). */
  lastPollMs?: number
  /** Number of consecutive heartbeat failures. */
  heartbeatFailures: number
  /** Number of consecutive poll failures. */
  pollFailures: number
  /** Current reconnection attempt (if reconnecting). */
  reconnectAttempt?: number
}
/** Lifecycle event for worker status changes. */
export interface LifecycleEvent {
  /** Event name (e.g., "starting", "registered", "ready", "paused", "resumed", "stopped") */
  eventName: string
  /** Timestamp in milliseconds since Unix epoch */
  timestampMs: number
  /** Optional additional data as JSON string */
  data?: string
}
/**
 * Client for workflow operations (not worker polling).
 *
 * NapiClient provides methods for:
 * - Starting workflows
 * - Querying workflow state
 * - Resolving/rejecting external promises
 */
export declare class NapiClient {
  /** Create a new NapiClient with the given configuration. */
  constructor(config: ClientConfig)
  /** Start a new workflow. */
  startWorkflow(workflowKind: string, input: string, options?: StartWorkflowOptions | undefined | null): Promise<StartWorkflowResult>
  /** Query a workflow. */
  queryWorkflow(workflowId: string, queryName: string, args: string): Promise<string>
  /** Resolve an external promise. */
  resolvePromise(promiseId: string, value: string): Promise<void>
  /** Reject an external promise. */
  rejectPromise(promiseId: string, error: string): Promise<void>
  /** Send a signal to an existing workflow. */
  signalWorkflow(workflowExecutionId: string, signalName: string, signalValue: string): Promise<SignalWorkflowResult>
  /** Send a signal to an existing workflow, or create a new workflow and send the signal. */
  signalWithStartWorkflow(workflowId: string, workflowKind: string, workflowInput: string, queue: string | undefined | null, signalName: string, signalValue: string): Promise<SignalWithStartResult>
  /** Get the server URL. */
  get serverUrl(): string
  /** Get the org ID. */
  get orgId(): string
}
/** Replay-aware workflow context for NAPI bindings. */
export declare class NapiWorkflowContext {
  /** Create a new context from activation data. */
  constructor(workflowExecutionId: string, orgId: string, timestampMs: number, randomSeed: string, replayEvents: Array<string>, stateEntries: Array<StateEntry>, cancellationRequested: boolean)
  /** Get the workflow execution ID. */
  get workflowExecutionId(): string
  /** Schedule a task for execution. */
  scheduleTask(kind: string, input: string, queue?: string | undefined | null, timeoutMs?: number | undefined | null): TaskResult
  /** Create a durable promise. */
  createPromise(name: string, timeoutMs?: number | undefined | null): PromiseResult
  /** Wait for the next signal in the queue. */
  waitForSignal(): SignalResult
  /** Check if any signals are pending in the queue. */
  hasSignal(): boolean
  /** Get the number of pending signals. */
  pendingSignalCount(): number
  /** Drain all pending signals from the queue. */
  drainSignals(): Array<SignalEvent>
  /** Start a timer. */
  startTimer(durationMs: number): TimerResult
  /** Schedule a child workflow. */
  scheduleChildWorkflow(name: string, kind: string | undefined | null, input: string, queue?: string | undefined | null, prioritySeconds?: number | undefined | null): ChildWorkflowResult
  /** Run a side effect operation. */
  runOperation(name: string): OperationResult
  /** Record the result of an operation. */
  recordOperationResult(name: string, result: string): void
  /** Get the current time in milliseconds. */
  currentTimeMillis(): number
  /** Generate a deterministic UUID. */
  randomUuid(): string
  /** Generate a deterministic random number in [0, 1). */
  random(): number
  /** Set workflow state. */
  setState(key: string, value: string): void
  /** Get workflow state. */
  getState(key: string): string | null
  /** Clear workflow state. */
  clearState(key: string): void
  /** Get all state keys. */
  stateKeys(): Array<string>
  /** Clear all workflow state. */
  clearAll(): void
  /** Check if cancellation has been requested. */
  get isCancellationRequested(): boolean
  /** Request cancellation. */
  requestCancellation(): void
  /** Take all generated commands as JSON string. */
  takeCommands(): string
  /** Get the number of pending commands. */
  commandCount(): number
}
/** Task context for NAPI, providing streaming and lifecycle APIs. */
export declare class NapiTaskContext {
  /** Get the task execution ID. */
  get taskExecutionId(): string
  /** Get the workflow execution ID. */
  get workflowExecutionId(): string | null
  /** Get the current attempt number. */
  get attempt(): number
  /** Check if the task has been cancelled. */
  get isCancelled(): boolean
  /** Stream a token. */
  streamToken(text: string): Promise<boolean>
  /** Stream progress. */
  streamProgress(progress: number, details?: string | undefined | null): Promise<boolean>
  /** Stream data. */
  streamData(data: string): Promise<boolean>
  /** Stream an error notification. */
  streamError(message: string, code?: string | undefined | null): Promise<boolean>
}
/**
 * The main worker object exposed to Node.js via NAPI.
 *
 * NapiWorker manages:
 * - Connection to the Flovyn server
 * - Worker registration
 * - Polling for workflow and task activations
 * - Processing completions
 */
export declare class NapiWorker {
  /** Create a new NapiWorker with the given configuration. */
  constructor(config: WorkerConfig)
  /** Register the worker with the Flovyn server. */
  register(): Promise<string>
  /**
   * Poll for the next workflow activation.
   * Returns plain activation data that the TypeScript SDK uses to create its own context.
   */
  pollWorkflowActivation(): Promise<WorkflowActivationData | null>
  /**
   * Complete a workflow activation.
   * The status.commands field contains the serialized commands from the context.
   */
  completeWorkflowActivation(workflowExecutionId: string, status: WorkflowCompletionStatus): Promise<void>
  /**
   * Poll for the next task activation.
   * Returns plain activation data for the TypeScript SDK.
   */
  pollTaskActivation(): Promise<TaskActivationData | null>
  /** Complete a task activation. */
  completeTask(completion: TaskCompletion): Promise<void>
  /** Initiate graceful shutdown of the worker. */
  shutdown(): void
  /** Check if shutdown has been requested. */
  get isShutdownRequested(): boolean
  /** Get the current worker status. */
  get status(): string
  /** Pause the worker. */
  pause(reason: string): void
  /** Resume the worker. */
  resume(): void
  /** Check if the worker is paused. */
  get isPaused(): boolean
  /** Check if the worker is running. */
  get isRunning(): boolean
  /** Get the pause reason. */
  get pauseReason(): string | null
  /** Get the maximum concurrent workflows setting. */
  get maxConcurrentWorkflows(): number
  /** Get the maximum concurrent tasks setting. */
  get maxConcurrentTasks(): number
  /** Get the queue name. */
  get queue(): string
  /** Get the org ID. */
  get orgId(): string
  /** Get the server URL. */
  get serverUrl(): string
  /** Get the worker identity. */
  get workerIdentity(): string | null
  /** Poll for lifecycle events. */
  pollLifecycleEvents(): Array<LifecycleEvent>
  /** Get the count of pending lifecycle events. */
  pendingLifecycleEventCount(): number
  /** Get the worker uptime in milliseconds. */
  get uptimeMs(): number
  /** Get the worker start time in milliseconds since Unix epoch. */
  get startedAtMs(): number
  /** Get the server-assigned worker ID. */
  get workerId(): string | null
  /** Get worker metrics. */
  getMetrics(): WorkerMetrics
  /** Get registration information. */
  getRegistrationInfo(): RegistrationInfo | null
  /** Get connection information. */
  getConnectionInfo(): ConnectionInfo
}
