/**
 * @flovyn/native - Native bindings for Flovyn TypeScript SDK.
 *
 * This package provides the low-level native bindings generated by NAPI-RS.
 * Most users should use @flovyn/sdk instead for the high-level API.
 *
 * @packageDocumentation
 */

import { loadNativeModule } from './loader';

// Load the native module
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const native = loadNativeModule() as any;

// Re-export types from the native module
// These are generated by NAPI-RS from the Rust code

// Configuration types
export type WorkerConfig = {
  serverUrl: string;
  orgId: string;
  queue: string;
  workerToken?: string;
  oauth2Credentials?: OAuth2Credentials;
  workerIdentity?: string;
  maxConcurrentWorkflowTasks?: number;
  maxConcurrentTasks?: number;
  workflowMetadata: WorkflowMetadata[];
  taskMetadata: TaskMetadata[];
};

export type ClientConfig = {
  serverUrl: string;
  orgId: string;
  clientToken?: string;
  oauth2Credentials?: OAuth2Credentials;
};

export type OAuth2Credentials = {
  clientId: string;
  clientSecret: string;
  tokenEndpoint: string;
  scopes?: string;
};

// Metadata types
export type WorkflowMetadata = {
  kind: string;
  name: string;
  description?: string;
  version?: string;
  tags: string[];
  cancellable: boolean;
  timeoutSeconds?: number;
  inputSchema?: string;
  outputSchema?: string;
};

export type TaskMetadata = {
  kind: string;
  name: string;
  description?: string;
  version?: string;
  tags: string[];
  cancellable: boolean;
  timeoutSeconds?: number;
  inputSchema?: string;
  outputSchema?: string;
};

// Activation types
export type WorkflowActivationData = {
  workflowExecutionId: string;
  orgId: string;
  workflowKind: string;
  input: string;
  jobs: WorkflowActivationJob[];
  replayEvents: string[];
  stateEntries: StateEntry[];
  timestampMs: number;
  randomSeed: string;
  cancellationRequested: boolean;
};

export type WorkflowActivationJob = {
  jobType: string;
  data: string;
};

export type StateEntry = {
  key: string;
  value: string;
};

export type TaskActivationData = {
  taskExecutionId: string;
  taskKind: string;
  input: string;
  workflowExecutionId?: string;
  attempt: number;
  maxRetries: number;
  timeoutMs?: number;
};

// Completion types
export type WorkflowCompletionStatus = {
  status: 'Completed' | 'Suspended' | 'Cancelled' | 'Failed';
  output?: string;
  reason?: string;
  error?: string;
  commands?: string;
};

export type TaskCompletion = {
  taskExecutionId: string;
  status: 'Completed' | 'Failed' | 'Cancelled';
  output?: string;
  error?: string;
  retryable?: boolean;
};

// Result types from context methods
export type TaskResult = {
  status: string;
  output?: string;
  error?: string;
  retryable?: boolean;
  taskExecutionId?: string;
};

export type PromiseResult = {
  status: string;
  value?: string;
  error?: string;
  promiseId: string;
};

export type TimerResult = {
  status: string;
  firedAtMs?: number;
  timerId: string;
};

export type ChildWorkflowResult = {
  status: string;
  output?: string;
  error?: string;
  childExecutionId?: string;
};

export type OperationResult = {
  status: string;
  value?: string;
  operationSeq?: number;
};

// Metrics and status types
export type WorkerMetrics = {
  uptimeMs: number;
  status: string;
  workerId?: string;
  workflowsProcessed: number;
  tasksProcessed: number;
  activeWorkflows: number;
  activeTasks: number;
};

export type RegistrationInfo = {
  workerId: string;
  success: boolean;
  registeredAtMs: number;
  workflowKinds: string[];
  taskKinds: string[];
  hasConflicts: boolean;
};

export type ConnectionInfo = {
  connected: boolean;
  lastHeartbeatMs?: number;
  lastPollMs?: number;
  heartbeatFailures: number;
  pollFailures: number;
  reconnectAttempt?: number;
};

export type LifecycleEvent = {
  eventName: string;
  timestampMs: number;
  data?: string;
};

// Start workflow result
export type StartWorkflowResult = {
  workflowExecutionId: string;
  idempotencyKeyUsed: boolean;
  idempotencyKeyNew: boolean;
};

export type StartWorkflowOptions = {
  queue?: string;
  workflowVersion?: string;
  idempotencyKey?: string;
};

// Export the native classes
export const NapiWorker: {
  new (config: WorkerConfig): NapiWorkerInstance;
} = native.NapiWorker;

export const NapiClient: {
  new (config: ClientConfig): NapiClientInstance;
} = native.NapiClient;

export const NapiWorkflowContext: {
  new (
    workflowExecutionId: string,
    orgId: string,
    timestampMs: number,
    randomSeed: string,
    replayEvents: string[],
    stateEntries: StateEntry[],
    cancellationRequested: boolean
  ): NapiWorkflowContextInstance;
} = native.NapiWorkflowContext;

// Instance type interfaces
export interface NapiWorkerInstance {
  register(): Promise<string>;
  pollWorkflowActivation(): Promise<WorkflowActivationData | null>;
  pollTaskActivation(): Promise<TaskActivationData | null>;
  completeWorkflowActivation(
    workflowExecutionId: string,
    status: WorkflowCompletionStatus
  ): Promise<void>;
  completeTask(completion: TaskCompletion): Promise<void>;
  shutdown(): Promise<void>;
  pause(reason?: string): void;
  resume(): void;
  pollLifecycleEvents(): LifecycleEvent[];
  getMetrics(): WorkerMetrics;
  getConnectionInfo(): ConnectionInfo;
  readonly isShutdownRequested: boolean;
  readonly isPaused: boolean;
  readonly pauseReason: string | null;
}

export type SignalWorkflowResult = {
  signalEventSequence: number;
};

export type SignalWithStartResult = {
  workflowExecutionId: string;
  workflowCreated: boolean;
  signalEventSequence: number;
};

export interface NapiClientInstance {
  startWorkflow(
    workflowKind: string,
    input: string,
    options?: StartWorkflowOptions
  ): Promise<StartWorkflowResult>;
  queryWorkflow(workflowId: string, queryName: string, args: string): Promise<string>;
  resolvePromise(promiseId: string, value: string): Promise<void>;
  rejectPromise(promiseId: string, error: string): Promise<void>;
  signalWorkflow(
    workflowExecutionId: string,
    signalName: string,
    signalValue: string
  ): Promise<SignalWorkflowResult>;
  signalWithStartWorkflow(
    workflowId: string,
    workflowKind: string,
    workflowInput: string,
    queue: string | undefined | null,
    signalName: string,
    signalValue: string
  ): Promise<SignalWithStartResult>;
  readonly serverUrl: string;
  readonly orgId: string;
}

export type SignalResult = {
  status: string;
  signalName?: string;
  value?: string;
};

export type SignalEvent = {
  signalName: string;
  value: string;
};

export interface NapiWorkflowContextInstance {
  scheduleTask(kind: string, input: string, queue?: string, timeoutMs?: number): TaskResult;
  createPromise(name: string, timeoutMs?: number): PromiseResult;
  startTimer(durationMs: number): TimerResult;
  scheduleChildWorkflow(
    name: string,
    kind: string | undefined,
    input: string,
    queue?: string,
    prioritySeconds?: number
  ): ChildWorkflowResult;
  runOperation(name: string): OperationResult;
  recordOperationResult(name: string, result: string): void;
  waitForSignal(signalName: string): SignalResult;
  hasSignal(signalName: string): boolean;
  pendingSignalCount(signalName: string): number;
  drainSignals(signalName: string): SignalEvent[];
  currentTimeMillis(): number;
  randomUuid(): string;
  random(): number;
  getState(key: string): string | null;
  setState(key: string, value: string): void;
  clearState(key: string): void;
  stateKeys(): string[];
  clearAll(): void;
  isCancellationRequested(): boolean;
  getCommandsJson(): string;
  takeCommands(): string;
  clearCommands(): void;
  readonly workflowExecutionId: string;
  readonly orgId: string;
}
